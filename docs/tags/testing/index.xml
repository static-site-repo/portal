<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>testing on Potioneer&#39;s Essays</title>
    <link>//william-yeh.net/tags/testing/</link>
    <description>Recent content in testing on Potioneer&#39;s Essays</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 13 Sep 2023 20:00:00 +0800</lastBuildDate><atom:link href="//william-yeh.net/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>從 Code Review 的小事看到大事</title>
      <link>//william-yeh.net/post/2023/09/on-code-review/</link>
      <pubDate>Wed, 13 Sep 2023 20:00:00 +0800</pubDate>
      
      <guid>//william-yeh.net/post/2023/09/on-code-review/</guid>
      <description>Opening 我很喜歡 Java 大師 Joshua Bloch 在《編程的頂尖對話》所說的： 即使是想把一個很小的程式寫對也是非常難的。 認為自己程式沒有 bug 就是在愚弄自己。程式肯定有 bug</description>
    </item>
    
    <item>
      <title>很簡單的東西，也要單元測試嗎？</title>
      <link>//william-yeh.net/post/2022/05/need-for-unit-testing/</link>
      <pubDate>Tue, 24 May 2022 12:00:00 +0800</pubDate>
      
      <guid>//william-yeh.net/post/2022/05/need-for-unit-testing/</guid>
      <description>&lt;p&gt;（改寫自公司內部 memo）&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;   &lt;!-- raw HTML omitted --&gt;   &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Hi all engineers,&lt;/p&gt;
&lt;p&gt;上完一整天單元測試課程之後，有同事問我：「有沒有標準來決定要不要寫單元測試？」&lt;/p&gt;
&lt;p&gt;剛讀完劉潤《&lt;a href=&#34;https://www.books.com.tw/products/0010919211&#34;&gt;底層邏輯&lt;/a&gt;》的我，對於這類疑似「注射器」的問句格外敏感。雖然我可以瀟灑引述 &lt;a href=&#34;https://www.tenlong.com.tw/products/9789864344000&#34;&gt;&lt;em&gt;Working Effectively with Legacy Code&lt;/em&gt;&lt;/a&gt; 的說法「我毫無疑問地將『遺留程式碼』定義為『&lt;strong&gt;沒有編寫測試的程式碼&lt;/strong&gt;』」：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;沒有編寫測試的程式碼是糟糕的程式碼——不管我們多麼細心地編寫它們，不管它們有多漂亮、物件導向或封裝良好。有了測試，我們就能夠迅速、可驗證地修改程式碼的行為。沒有測試，我們就不知道修改後的程式碼，實際上是變得更好還是更糟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但當下我還是決定先展開一場對話。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gRPC 測試工具</title>
      <link>//william-yeh.net/post/2020/04/grpc-testing-tools/</link>
      <pubDate>Tue, 14 Apr 2020 22:00:00 +0800</pubDate>
      
      <guid>//william-yeh.net/post/2020/04/grpc-testing-tools/</guid>
      <description>&lt;p&gt;RESTful API 時代，我們有許多簡單好用的測試工具：有酷炫的 &lt;a href=&#34;https://www.postman.com/&#34;&gt;Postman&lt;/a&gt;，有命令列控愛用的 &lt;a href=&#34;https://httpie.org/&#34;&gt;HTTPie&lt;/a&gt;，當然也有硬漢必備的萬用瑞士刀 &lt;a href=&#34;https://curl.haxx.se/&#34;&gt;curl&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;那麼，gRPC 呢？&lt;/p&gt;
&lt;p&gt;這篇文章介紹兩個好用的小工具：&lt;a href=&#34;https://github.com/fullstorydev/grpcurl&#34;&gt;gRPCurl&lt;/a&gt; 及 &lt;a href=&#34;https://github.com/bojand/ghz&#34;&gt;ghz&lt;/a&gt;，一個是輸入輸出介面測試工具，另一個是壓測工具，也順便介紹一些簡化測試的技巧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CI 怎樣帶你遠離平庸？</title>
      <link>//william-yeh.net/post/2015/12/ci-effect/</link>
      <pubDate>Tue, 22 Dec 2015 08:00:00 +0800</pubDate>
      
      <guid>//william-yeh.net/post/2015/12/ci-effect/</guid>
      <description>前天我的文章〈CI 是條不歸路〉提到：「CI/CD/DevOps 既是條不歸路，更是大躍進之路：一旦踏出第一步，就注定你會不斷接觸**『遠離平庸</description>
    </item>
    
  </channel>
</rss>
